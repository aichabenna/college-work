/*BENNAGHMOUCH Aicha GROUPE D */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <sys/wait.h> /* wait */
#include <fcntl.h>
#include <errno.h>

#include "readcmd.h"
#include "listJobs.h"

listJobs * list;
pid_t current_pid;
int length;
int ctlr_c;
int ctlr_z;

void listerJobs(){
    print_list(list);
}

void stopJob(char ** arg){
    if(arg[1] == 0){
        printf("wrong use of cmd 'sj'\n");
    }else{
        pid_t pid = get_pid(list, atoi(arg[1]));
        if (pid == -1){
            printf("Inexistant ID\n");
        }else{
            kill(pid, SIGSTOP);
            set_etat(list, pid, SUSPENDU);
        }
    }
}

void backgroundedJob(char ** arg){
    if(arg[1] == 0){
        printf("wrong use of cmd 'bg'\n");
    }else{
        pid_t pid = get_pid(list, atoi(arg[1]));
        if (pid == -1){
            printf("Inexistant ID\n");
        }else{
            kill(pid, SIGCONT);
            set_etat(list, pid, ACTIF_BG);
        }
    }
}

void forgroundedJob(char ** arg){
    if(arg[1] == 0){
        printf("wrong use of cmd 'fg'\n");
    }else{
        pid_t pid = get_pid(list, atoi(arg[1]));
        if (pid == -1){
            printf("Inexistant ID\n");
        }else{
            int time;
            set_etat(list, pid, ACTIF_FG);
            kill(pid, SIGCONT);
            wait(&time);
            delete_job(list, pid);
        }
    }
}
/*************************** HANDLERS ************************/

void handler_SIGINT(int signal_num){
    if(current_pid != 0){
        kill(current_pid, SIGKILL);
        delete_job(list,current_pid);
        ctlr_c = 1;
    }
    printf("\n");
}

void handler_SIGCHLD(int signal_num){
    int wstatus ;
    pid_t pid;
    if (signal_num == SIGCHLD) {
        while ((pid = (int) waitpid(-1, &wstatus, WNOHANG | WUNTRACED | WCONTINUED)) > 0) {
            if (pid==-1){
                if(errno != ECHILD) {
                    perror("\nerror waitpid\n");
                    exit(EXIT_FAILURE);
                }
            }
            if (WIFEXITED(wstatus) || WIFSIGNALED(wstatus)) {
                delete_job(list, pid);
                length--;
                current_pid = 0;
            } else if (WIFCONTINUED(wstatus)) {
                set_etat(list, pid, ACTIF_FG);
            } else if (WIFSTOPPED(wstatus)) {
                set_etat(list, pid, SUSPENDU);
            }
        }
     }
}

void handler_SIGTSTP(int signal_num){
    if(current_pid != 0){
        kill(current_pid, SIGSTOP);
        set_etat(list,current_pid, SUSPENDU);
        ctlr_z = 1;
    }
}
/*************************************************************/
// Redirections entrées/ sorties
void redirection_entree_sortie (char* in, char* out) {
    if (in != NULL) {
        int entree = open(in, O_RDONLY);
        if (entree < 0) {
            printf("open error");
        }
        int err = dup2(entree,0);
        if (test < 0) {
            printf("dup2 error");
        }
    }
    if (out != NULL) {
        int sortie = open(out, O_WRONLY|O_CREAT| O_TRUNC, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH);
        if (sortie < 0) {
            printf("open error");
        }
        int erreur = dup2(sortie,1);
        if (test < 0) {
            printf("dup2 error");
        }
    }
}

//compter le nombre de tubes à créer
int pipe_count(struct cmdline *cmd){
    int pipes = 0;
    while(cmd->seq[pipes] != NULL){
        pipes++;
    }
    return pipes -1;
}


/*************************************************************/

int main(){
    initialise_list(list);
    length= 1;
    struct cmdline * cmdline;
    int pidFils;
    int wstatus;
    int id =1;
    char s[100];
    const int copie0 = dup(0);
	const int copie1 = dup(1);
    signal(SIGCHLD, handler_SIGCHLD);
    signal(SIGTSTP, handler_SIGTSTP);
    signal(SIGINT, handler_SIGINT);
    while(1){
        printf("abennagh@user:~%s$ ", getcwd(s,100));
        dup2(copie0, 0);
        dup2(copie1, 1);
        do{
            cmdline = readcmd();
        } while (cmdline == NULL);

        current_pid = 0;
        ctlr_c = 0;
        ctlr_z = 0;
        int pipes = pipe_count(cmdline);
        int p[pipes][2];

        if (feof(stdin)){
            printf("exit\n");
            break;
        }
        if (cmdline->seq != NULL){
            if(cmdline->in !=NULL || cmdline->out !=NULL){
                redirection_entree_sortie(cmdline->in, cmdline->out);
            }
        }
        if(cmdline->seq[0] != NULL){
            if(strcmp(cmdline->seq[0][0], "cd") == 0){
                if(cmdline->seq[0][1] == NULL || !strcmp(cmdline->seq[0][1], "~")){
                    chdir(getenv("HOME"));
                }
                chdir(cmdline->seq[0][1]);
            }else if (strcmp(cmdline->seq[0][0], "exit") == 0){
                exit(EXIT_SUCCESS);
            }else if (strcmp(cmdline->seq[0][0], "lj") == 0){
                listerJobs();
            }else if (strcmp(cmdline->seq[0][0], "sj") == 0){
                stopJob(cmdline->seq[0]);
            }else if (strcmp(cmdline->seq[0][0], "bg") == 0){
                backgroundedJob(cmdline->seq[0]);
            } else if (strcmp(cmdline->seq[0][0], "fg") == 0){
                forgroundedJob(cmdline->seq[0]);
            } else if (strcmp(cmdline->seq[0][0], "susp") == 0){
                stopJob(cmdline->seq[0]);
            } else{                
                if(pipes >0){
                    for(int i=0; i<pipes; i++){
                        int ret = pipe(p[i]);
                        if(ret ==-1){
                            printf("pipe error\n");
                            exit(1);
                        }
                    } 
                    for(int i=0; i<pipes; i++){
                        int pid =fork();
                        if(pid==-1){
                            printf("Erreur fork()\n");
                        }
                        if(pid == 0){
                            // fermer la lecture de la première commande 
                            close(p[i][0]);
                            // fermer l'écriture de la première commande 
                            if(i+1 < pipes){
                                close(p[i+1][1]);
                            }

                            // fermer tous les autres tubes restants
                            for (int j=0; j<pipes; j++){
                                if(i != j && (i+1) != j){
                                    close(p[j][0]);
                                    close(p[j][1]);
                                }
                            }
                            // gérer les lectures et écritures des deux commandes 
                            // composants le tube en cours d'exécution
                            dup2(p[i][1], 1);
                            if(i+1<pipes ){
                                dup2(p[i][0], 0);
                            }
                            execvp(cmdline->seq[i][0], cmdline->seq[i]);
                            close(p[i][1]);
                            if(i+1<pipes ){
                                close(p[i+1][1]);
                            }
                        } else{
                            close (p[i][1]);
                            dup2(p[i][0],0);
                            if(cmdline->backgrounded == NULL){
                                list = add_job(list, pid, *cmdline->seq[i], ACTIF_FG, id);
                                id++;
                                waitpid(pid, &wstatus, 0);
                                delete_job(list, pid);
                            }else{
                                list = add_job(list, pid, *cmdline->seq[i], ACTIF_BG, id);
                                current_pid = pid;
                                id++;
                                length++;
                            }
                        }
                    }
                }
                pidFils = fork();
                if(pidFils == -1){
                    printf("Erreur fork()\n");
                }
                if (pidFils == 0){
                    close(p[pipes][1]);
                    int retour = execvp(cmdline->seq[pipes][0], cmdline->seq[pipes]);
                    dup2(p[pipes][0],1);
                    if(retour == -1){
                        perror("Erreur\n");
                    }
                    exit(EXIT_SUCCESS);
                    close(p[pipes][0]);

                }else{
                    if(cmdline->backgrounded == NULL){
                        list = add_job(list, pidFils, *cmdline->seq[0], ACTIF_FG, id);
                        id++;
                        waitpid(pidFils, &wstatus, 0);
                        delete_job(list, pidFils);
                    }else{
                        list = add_job(list, pidFils, *cmdline->seq[0], ACTIF_BG, id);
                        current_pid = pidFils;
                        id++;
                        length++;
                    }
                }
            } 
        }
    }
    return EXIT_SUCCESS;
}