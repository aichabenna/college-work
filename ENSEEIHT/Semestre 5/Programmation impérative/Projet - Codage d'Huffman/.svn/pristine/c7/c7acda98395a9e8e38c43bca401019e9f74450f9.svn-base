with Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with LCA;
with TREE;

procedure Compresser is

   type T_Octet is mod 2 ** 8;	-- sur 8 bits
   for T_Octet'Size use 8;

   File_Name : String :=  "exemple_fichier.out";
   File      : Ada.Streams.Stream_IO.File_Type;	-- car il y a aussi Ada.Text_IO.File_Type
   S         : Stream_Access;
   Octet     : T_Octet;

   package Tree_Octet_Integer is
     new TREE (T_Id => T_Octet, T_Data => Integer);
   use Tree_Octet_Integer;

   package LCA_Integer_Octet is
     new LCA (T_Cle => T_Octet, T_Donnee => Integer);
   use LCA_Integer_Octet;

   package LCA_Integer_Tree is
     new LCA (T_Cle => Integer, T_Donnee => T_Tree);
   use LCA_Integer_Tree;

--Convertie une liste d'octet en liste de feuille
   Procedure To_leaf(Liste_Tree : out LCA_Integer_Tree.T_Lca ; Liste_Octet : in LCA_Integer_Octet.T_Lca ; i : in Integer) is
      Leaf : T_Tree ;
   begin
      if not Est_Vide(Liste_Octet) then
         Create_Leaf(Leaf,La_Cle(Liste_Octet),La_Donnee(Liste_Octet,La_Cle(Liste_Octet)));
         Enregistrer(Liste_Tree,i,Leaf);
         New_Line;
         put(i);
         To_Leaf(Liste_Tree,Suivant(Liste_Octet),i+1);
      end if;
   end To_leaf;

   Liste_Octet : LCA_Integer_Octet.T_LCA;
   Liste_Tree : LCA_Integer_Tree.T_LCA;
   Position_octet : LCA_Integer_Octet.T_LCA;
   Tree : T_Tree;
   cpt : Integer := 0;


   procedure Print_tree(Tree: in T_tree; espace : in integer) is
   begin
        Put("(");
        Put(data(tree),1);
        Put(")");

        for i in 1..espace loop
         if espace=1 then
            New_line;
                Put("|");
            end if;
            Put("    ");
        end loop;

        if is_leaf(tree)  then
            Put("'" & Character'Val(id(tree)) & "'");
            New_line;
        end if;
        if not is_empty(left (tree)) then
            Put("\--0--");
            print_tree(left(tree), espace+1);
        end if;
        if not is_empty(right (tree)) then
            Put("\--1--");
            print_tree(right(tree), espace+1);
        end if;

    end print_tree;

   procedure Afficher_LCA_Octet (S : in T_Octet; N: in Integer) is
   begin
      Put (Character'Val(S));
      Put (" : ");
      Put (N);
      New_Line;
   end Afficher_LCA_Octet;

   -- Afficher la Sda_Octet
   procedure Afficher_LCA_Octet is
     new LCA_Integer_Octet.Pour_Chaque (Afficher_LCA_Octet);


   procedure Afficher_LCA_Tree (S : in Integer; N: in T_Tree) is
   begin
      Put (S);
      Put (" : ");
      Print_Tree(N,0);
      New_Line;
   end Afficher_LCA_Tree;

   -- Afficher la Sda_Tree
   procedure Afficher_LCA_Tree is
     new LCA_Integer_Tree.Pour_Chaque (Afficher_LCA_Tree);

   --Trouver la plus petite occurence et son indice
   procedure min_Tree(Liste_Tree : in LCA_Integer_Tree.T_Lca ; Tree : in out T_Tree ; Cle : in out Integer) is
   begin
      if not Est_Vide(Liste_Tree) then
         if data(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))) < data(tree) then
            Cle := LCA_Integer_Tree.La_Cle(Liste_Tree);
            Create_Node(Tree,left(LCA_Integer_Tree.La_Donnee(Liste_Tree,Cle)),right(LCA_Integer_Tree.La_Donnee(Liste_Tree,Cle)),id(LCA_Integer_Tree.La_Donnee(Liste_Tree,Cle)),data(LCA_Integer_Tree.La_Donnee(Liste_Tree,Cle)));
         end if;
         min_Tree(LCA_Integer_Tree.Suivant(Liste_Tree),Tree , Cle);
      end if;

   end min_Tree;

   --Construit l'arbre de Huffman
   procedure Huffman_Tree (Liste_Tree : in out LCA_Integer_Tree.T_Lca ; Tree : out T_Tree) is
      Tree_g : T_Tree;
      Tree_d : T_Tree;
      Node : T_Tree;
      Cle : Integer;
      Taille : Integer := LCA_Integer_Tree.Taille(Liste_Tree);
   begin
      while LCA_Integer_Tree.Taille(Liste_Tree)>1 loop
         Create_Node(Tree_g,left(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))),right(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))),id(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))),data(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree)))); --on suppose que la 1er valeur est la plus petite
         Cle := La_Cle(Liste_Tree);
         min_Tree(Liste_Tree,Tree_g,Cle); --Tree_g est le vrai minimum
         Supprimer(Liste_Tree,Cle);

         Create_Node(Tree_d,left(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))),right(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))),id(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree))),data(LCA_Integer_Tree.La_Donnee(Liste_Tree,LCA_Integer_Tree.La_Cle(Liste_Tree)))); --on suppose que la 1er valeur est la plus petite
         Cle := La_Cle(Liste_Tree);
         min_Tree(Liste_Tree,Tree_d,Cle); --Tree_d est le vrai deuxiËme minimum
         Supprimer(Liste_Tree,Cle);

         Create_Node(Node,Tree_g,Tree_d,T_Octet(27),data(Tree_g)+data(Tree_d));
         Taille := Taille+1;

         Enregistrer(Liste_Tree,Taille,Node);
      end loop;
      Create_Node(Tree,left(Node),right(Node),T_Octet(27),data(Node));


   end Huffman_Tree;

   --resortir position de chaques caractËres
   procedure position(tree : in T_Tree; Liste : in out LCA_Integer_Octet.T_LCA ; cpt : in out integer) is
   begin
      if is_leaf(Tree) then
         LCA_Integer_Octet.Enregistrer(liste,id(Tree),cpt);
         cpt:=cpt+1;
      else
         position(left(Tree),Liste,cpt);
         position(right(Tree),Liste,cpt);
      end if;
   end position;

begin

   -- Erire les premiers octets dans un fichier
   -- ------------------------------------------
   --   Cr√©er un fichier en √©criture (√©crasement si existant)
   Create (File, Out_File, File_Name);

   --   Ecrire dans le fichier via un Stream
   --   (on pourrait √©crire des donn√©es de type diff√©rents)
   S := Stream (File);
  -- for I in 0..128 loop
     -- T_Octet'Write(S, T_Octet(I));
   --   T_Octet'Write(S, T_Octet(2));
  --end loop;

 --for I in 0..1 loop
      T_Octet'Write(S, T_Octet(102));
      T_Octet'Write(S, T_Octet(102));
      T_Octet'Write(S, T_Octet(104));
      T_Octet'Write(S, T_Octet(107));
      T_Octet'Write(S, T_Octet(107));
      T_Octet'Write(S, T_Octet(107));

  -- end loop;

   --   Fermer le fichier
   Close (File);


	--   Ouvrir le fichier en lecture
   Open(File, In_File, File_Name);

	--   Lire, v√©rifier et afficher de temps en temps le contenu
	--   Attention, il faut lire les donn√©es dans le m√™me ordre qu'elles ont √©t√© √©crite.
 --   Ici, le probl√®me ne se pose pas car il n'y a que des octets.

   Initialiser(Liste_Octet);
   S := Stream(File);
   while not End_Of_File(File) loop
      Octet := T_Octet'Input(S);
      --
      if Cle_Presente(Liste_Octet,Octet) then
         Enregistrer(Liste_Octet,Octet,La_Donnee(Liste_Octet,Octet)+1);
      else
         Enregistrer(Liste_Octet,Octet,1);
      end if;

   end loop;

   Close (File);

--On ajoute le caractËre de fin de ficher (eot)position_octet : LCA_Integer_Octet.T_LCA;

   Enregistrer(Liste_Octet,T_Octet(4),0);


  -- Afficher_LCA_Octet(Liste_Octet);

   To_leaf(Liste_Tree,Liste_Octet,1);

  -- Afficher_LCA_Tree(Liste_Tree);

   Huffman_Tree(Liste_Tree, Tree);

 --  Afficher_LCA_Tree(Liste_Tree);

   New_Line;
   Print_tree(Tree,0);

   position(Tree,Position_octet,cpt);
   Afficher_LCA_Octet(Position_Octet);

   --On crÈe le fichier compressÈ
   Create (File, Out_File, File_Name);






end Compresser;
