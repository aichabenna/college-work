Exercice 1: Libération de la mémoire

Exercice 2: Détecter les fuites de mémoire
1- valgrind ./exemples_memoire_dynamique
2- Valgrind nous indique qu'une zone mémoire n'a pas été désallouée. Ceci dans la ligne 31.
3- Pour corriger l'erreur, on ajoute Free(Ptr1) après la ligne 33.

Exercice 3: Danger lié aux pointeurs
1-
2- 
3- On remarque trois erreurs de deux types : 
- "Invalid read of size 4" dans les lignes 56 et 59. On essaie d'aacéder à une zone mémoire déjà désallouée.
- "Invalid write of size 4" dans la ligne 5. On essaie d'écrire dans une zone mémoire déjà désallouée.

Exercice 4: Passage de paramètre in et pointeurs
Affichage du programme: 123
On passe l'adresse du pointeur en paramètre et pas son contenue. De ce fait, on peut modifier le valeur pointée

Exercice 5: Structures Chainées et variables locales
1- Il faut détruire la zone mémoire de la variable locale.
2- En effet, après exécution du programme et appel de valgrind, on a une fuite de mémoire ( certaines zones allouées n'ont pas été désallouées).
3- Pour corriger le programme, il suffit d'ajouter dans la ligne 110: Detruire(P).

Exercice 6: Erreurs difficiles à trouver liées à la mauvaise utilisation des pointeurs
1-
2- Les erreurs indiquées dans l'exercice 2.
3-  Pour corriger les erreurs, on peut:
- Soit commenter les lignes 56, 58 et 59.
- Soit déplacer les lignes 50, 52 et 53 après la ligne 59.
4- Il faut éviter d'avoir deux pointeurs qui pointent vers la même adresse et bien désallouer.

Exercice 7: Affectation entre structures chaînées
1- 
3- Limited private : pas d'affectations etde test d'égalités sur des éléments du type T_pile.
Intérêt: Dans ce cas, "limited private" nous évite d'avoir deux pointeurs qui pointent vers la même zone et évite d'avoir les fuites de mémoire.
